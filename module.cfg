{
	"arguments": [
		"--force-strict-mode",
		"--set-fps=60",
		"--vsync=1",
		"--auto-size-window",
		"--virtual-window-width=800",
		"--virtual-window-height=600",
		"--virtual-window-width-max=1066",
		"--play-sound-function=lib.sound.play_sound(me, sound)",
		"--play-music-function=lib.audio.play_music(obj, music)",
		"--ffl-allow-obj-api-from-class=true"
	],
	"custom_arguments": {
		"hax": false,
		"lucre": false,
		"supes": false
	},
	"dependencies": "gui",
	"font": "bitmap",
	"id": "frogatto",
	"min_engine_version": 1.4,
	"name": "Frogatto & Friends",
	"player_type": "obj player_controlled",
	"version": [
		0,
		15
	],

		/*
			This can run any kind of validation we want against all (loaded) objects on launch.  This won't go through the full object tree (unless we're using whatever that option is that lets us test all objects, rather it'll just do the current level's objects.  This lets us statically validate things that are based on more primitive engine features (properties which objects can freely have or not have, such as solidity) which aren't something object types can 'hoard' to just themselves (we can't mandate everything that uses solidity to be a certain kind of object with certain guaranteed behavior).
			
			That option might be ` --utility=test_all_objects`
			
			This can return either a string or null - any string is considered a failure case; null is considered a success.  Note that it will automatically spit out the name of the offending object, so you don't need to do string interpolation to provide that.
		*/
	validate_objects: "def(map definition, [string] protos) ->string|null
		if((definition.solid_area or definition.platform_area) and 'cosmetic_effects' not in protos,
			'objects with solid_area or platform_area must be derived from cosmetic_effects'
		)
	",
}

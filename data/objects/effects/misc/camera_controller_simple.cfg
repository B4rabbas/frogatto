{
	id: "camera_controller_simple", //2, a strict-mode version
	always_active: true, //Hack until we figure out the appropriate bounding box.
	hidden_in_game: true,
	is_strict: true,
	prototype: ["standard_values"],

	editor_info: {     
		category: "controllers",
	},

	properties: {

		path: {type: "[[decimal,decimal]|map|object]", editor_info: {type: "points", value: "[]",},},
	
			/*
				during the camera sequence, we do use callbacks on every step to kick off the next leg of the camera motion, but this is the "big one" at the very end that isn't about doing a camera motion - this is the one that actually focuses on a game-world change like a gate opening, or whatnot.			
			*/
		final_callback: {type: "commands", default: null },  

	#-------------------------- data standardization --------------------------#
			/*
				Paths can be expressed (for convenience) as either points (in either [int,int], or {x:int,y:int} format, or they can be expressed as an object, in which case we extract the midpoint.   To get anything done, naturally we have to coerce a standardized format out of these.
			*/
		position_of_path_element_at_index: "def(int index) -> [decimal,decimal] 
			if(path[index] is [decimal,decimal],
				[decimal,decimal] <- path[index],
				[decimal,decimal] <- [an_object.mid_x, an_object.mid_y]
					where an_object = (custom_obj <- path[index])
			)
		",

		_path_as_points: "[[decimal,decimal]] :: map(me.path, position_of_path_element_at_index(index))",

	#-------------------------- core behavior --------------------------#
		internal_do_individual_camera_pan: "def(
			[decimal,decimal] target_pos,
			decimal target_zoom,
			commands callback,
			int callback_delay=80,
			int duration=200
		) -> commands 
			animate(me, {
				level_zoom: target_zoom,
				camera_mid_pos: target_pos,    ///TODO: find out what the hell we need to set here
			},{
				duration: duration,
				easing: lib.math.ease_in_out_sine,
				on_complete: callback,
			})
		",


		
		
		
		internal_do_pan_sequence: "def(
				int index,
				[[decimal,decimal]] steps,
				decimal target_zoom,
				int last_step_duration=80,
		) -> commands
		
			internal_do_individual_camera_pan(
				dest,
				target_zoom,
				[
					if(size(steps) > 1,
						internal_do_pan_sequence(index+1, steps[1:size(steps)], target_zoom, last_step_duration),
						
						//stuff done at the very end:
						[
							final_callback,
							level.player.remove_control_lock('camera_controller_pan'),
						]
					)
				],
				if(at_last_step, 0, last_step_duration),
				200
			)
		
				where at_last_step = (size(steps) = 1)
				where source = if(index = 0, level.player, steps[0])
				where dest = if(size(steps) > 1, steps[1], level.player.mid_xy)
		",



		do_pan_sequence: "[
			internal_do_pan_sequence(
				0,
				_path_as_points,
				2.0,
			),
			level.player.add_control_lock([], 'camera_controller_pan'),
		]",
	},
}
{
id: "dialog_controller",
always_active: true,
is_strict: true,
hidden_in_game: true,
prototype: ["standard_values"],
zorder: "@include data/zorder.cfg:in_front_of_everything",

/*
	A controller to help with making things talk in a reasonable way.
	Hopefully, more information is up on the wiki at
		https://github.com/frogatto/frogatto/wiki/dialog-controller
	
	Definitions:
		line:   One physical line of text in the dialog box. Not really related
		        to a sentence, because long sentences can take multiple lines to
		        display. Generated from parts.
		part:   A collection of sentences that a speaker says without
		        interruption. Marked up with XML.
		page:   The visual panel in which lines are drawn. Multiple lines can
		        appear on a page, and pressing a key will display the next line
		        in the part or advance the script.
		scene:  A collection of XML, actors (anything that's reasonably a point
		        on the level, like an object or some coordinates), and commands.
	
	Markup Guide:
		<br/>, \\n - Hard return. Enter replacement. You should almost always
			just use enter anyway, the leading whitespace gets trimmed. Text 
			that is too long to fit on a line is automatically wrapped.
		<page/> - Page feed. Regardless of if the page is full, advance to a 
			new page before displaying the next line.
		<pause time="200ms" />, \\p - Pause for a moment before displaying the
			next character.
		\\s - Sometimes, you do want leading whitespace. Use \\s to prevent 
			trimming of any following whitespace on a line.
		<b>text</b> or <strong>text</strong> - bold text
		<i>text</i> or <em>text</em> - italicised text
		<word-by-word>text</word-by-word> - Make the text appear word by word 
			instead of letter by letter. Usually indicates the speaker IS. 
			VERY. ANGRY. (Words are whitespace-delimited. You may use a 
			no-break space, i.e. « », if you want to join multiple words.)
		
		You can also add more effect tags yourself, by adding them to your 
			module's ~data/dialog_effect_tags.cfg file.
*/

editor_info: {
	category: "controllers",
	help: "A controller to assist with dialog. Script it in the level file."
},

properties: {
	custom_storage: { type: "{string -> any}", default: {} },
	
	//Overwrite these with your own npc types in your module with @derive.
	cast: { 
		type: "{string -> obj standing_npc | obj player_controlled_platformer_character}", 
		default: {},
	},
	props: { type: "{string -> custom_obj}", default: {} },
	scenes: { 
		type: "{string -> [commands]}",
		default: {},
	},
	_parsed_scenes: { type: "{string -> [commands]}", default: {} },
	camera: "object('camera_controller', 0, 0, 0, {
		average_path: true,
		last_preview_route: true,
		passepartout: 'standard',
		release_control: false,
		speed: 15,
		tween_type: 'ease_in_out_cubic',
		start_with_player_as_first_node: true,
		linked_delay: 0,
	})",
	
	before_script: { type: "commands", default: [] },
	after_script: { type: "commands", default: [] },
	
	zoom: { type: "decimal", default: 2 }, //something like this
	
	lines_per_page: 2,
	dialog_type: { type: "DialogType", default: "@eval enum debug" },
	
	playing: { type: "bool", default: false },
	skip_dialog: { type: "bool", default: false },
	
	line: "def(custom_obj actor, XMLString lines) -> commands
		debug(line); sleep(0.5)
	",
	
	//display_line: "def(XML line) -> commands 
	//	debug(line); 
	//	sleep(0.5)",
	//
	//display_lines: "def(XML part) -> commands 
	//	break_into_lines(lines)
	//",
	//
	//break_into_lines: "def(XMLString part) -> XML
	//	flatten(
	//		map(
	//			map(
	//				split(part, '<br/>'), 
	//				map(
	//					value, 
	//					value.split('\\n')
	//				)
	//			),
	//			
	//		)
	//	)
	//",
	
	parse_part: "def(XMLString part) -> XMLTokenList
		XMLTokenList <- parse_xml('<root>'+part+'</root>') //Returns a string on error.
	",
	
	parse_scene: "def(scene) -> [commands] []",
	parse_scenes: "def(scenes) -> {string -> [commands]} {}",
	
	run_scene: "def(scene_name) -> [commands]
		_parsed_scenes[scene_name] asserting scene_name in scenes",
	
	start: "commands ::
		debug('1. starting…');
		level.player.add_control_lock([], me);
	
		camera.add();
		set(camera.target_zoom, 2);
		set(camera.path, [level.player]);
		set(camera.release_control, false);
		set(camera.start_with_player_as_first_node, true);
		camera.go();
		
		debug('2. running…');
		run_scene('start');
		debug('3. ending…');
		
		set(camera.target_zoom, 1);
		set(camera.path, []);
		set(camera.release_control, true);
		set(camera.start_with_player_as_first_node, false);
		camera.go();
		camera.remove();
		
		level.player.remove_control_lock(me);
		debug('4. ended.')
	"
},

on_create: "debug('tz ' + zoom); sleep(0.5); start",
on_done_create: "set(_parsed_scenes, parse_scenes(scenes))", //Try to detect errors early.

on_triggered: "start",

animation: {
	id: "normal",
	image: "effects/particles.png",
	x: 86, y: 73, w: 28, h: 28,
	duration: -1,
},
}